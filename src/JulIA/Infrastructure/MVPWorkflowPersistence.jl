module MVPWorkflowPersistence

using SQLite
using Dates
using UUIDs # For uuid4() if generating IDs here, or for type hinting if IDs are UUIDs
using DataFrames # For handling SQLite query results

export init_db, save_workflow, load_workflow_details, list_workflows

const TABLE_NAME = "mvp_workflows"

"""
Initializes the database and creates the mvp_workflows table if it doesn't exist.
"""
function init_db(db_path::String)
    db = SQLite.DB(db_path)
    SQLite.execute(db, """
    CREATE TABLE IF NOT EXISTS $(TABLE_NAME) (
        id TEXT PRIMARY KEY,
        name TEXT,
        description TEXT,
        json_definition TEXT,
        created_at TEXT NOT NULL
    )
    """)
    # SQLite.close(db) # Keep db open if functions below take db object, or open/close per function
    # For this design, each function will open/close its own connection for simplicity.
end

"""
Saves a workflow to the database.
`id` should be a unique string (e.g., generated by uuid4() then string()).
Returns true on success, false on failure.
"""
function save_workflow(db_path::String, id::String, name::String, description::String, json_definition::String)::Bool
    db = SQLite.DB(db_path)
    created_at_str = Dates.format(now(UTC), Dates.ISODateTimeFormat)
    stmt = SQLite.Stmt(db, "INSERT INTO $(TABLE_NAME) (id, name, description, json_definition, created_at) VALUES (?, ?, ?, ?, ?)")
    try
        SQLite.bind!(stmt, [id, name, description, json_definition, created_at_str])
        SQLite.execute!(stmt)
        return true
    catch e
        @error "Failed to save workflow with ID $(id) to SQLite" exception=(e, catch_backtrace())
        return false
    finally
        SQLite.close(db) # Ensure DB is closed
    end
end

"""
Loads workflow details (id, name, description, json_definition, created_at) for a given ID.
Returns a NamedTuple or nothing if not found.
"""
function load_workflow_details(db_path::String, id::String)::Union{NamedTuple{(:id, :name, :description, :json_definition, :created_at), Tuple{String, String, String, String, String}}, Nothing}
    db = SQLite.DB(db_path)
    stmt = SQLite.Stmt(db, "SELECT id, name, description, json_definition, created_at FROM $(TABLE_NAME) WHERE id = ?")
    results = nothing
    try
        results = DBInterface.execute(stmt, [id]) |> DataFrame
    catch e
        @error "Failed to load workflow with ID $(id) from SQLite" exception=(e, catch_backtrace())
        return nothing # Error case
    finally
        SQLite.close(db)
    end

    if isempty(results)
        return nothing
    else
        row = results[1, :] # Get the first row
        return (id=row.id, name=row.name, description=row.description, json_definition=row.json_definition, created_at=row.created_at)
    end
end

"""
Lists basic information (id, name, description, created_at) for all workflows.
Returns a Vector of Dictionaries.
"""
function list_workflows(db_path::String)::Vector{Dict{String, Any}}
    db = SQLite.DB(db_path)
    workflows_list = Vector{Dict{String, Any}}()
    stmt = SQLite.Stmt(db, "SELECT id, name, description, created_at FROM $(TABLE_NAME) ORDER BY created_at DESC")
    results = nothing
    try
        results = DBInterface.execute(stmt) |> DataFrame
    catch e
        @error "Failed to list workflows from SQLite" exception=(e, catch_backtrace())
        # Return empty list on error, or rethrow depending on desired behavior
        return workflows_list
    finally
        SQLite.close(db)
    end

    for row in eachrow(results)
        push!(workflows_list, Dict(
            "id" => row.id,
            "name" => row.name,
            "description" => row.description,
            "created_at" => row.created_at
        ))
    end
    return workflows_list
end

end # module MVPWorkflowPersistence
